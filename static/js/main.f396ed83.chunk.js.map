{"version":3,"sources":["check.ts","highlighting.ts","full rez pics/darkBishop.png","initialBoard.ts","full rez pics/darkRook.png","full rez pics/darkKnight.png","full rez pics/darkQueen.png","full rez pics/darkKing.png","full rez pics/darkPawn.png","full rez pics/lightRook.png","full rez pics/lightKnight.png","full rez pics/lightBishop.png","full rez pics/lightQueen.png","full rez pics/lightKing.png","full rez pics/lightPawn.png","sharedMoveLogic.ts","move.ts","index.js","startAnalysis.ts"],"names":["willMovingHereCheckMe","board_copy","move_x","move_y","i","j","pieceInvestigating","currentColor","color","simualtingBoard","JSON","parse","stringify","copyForPawnMovementAnalysis","image","piece","move","length","findMyKing","king_x","king_y","enemyPossibleCaptureLocations","getAllAttackLocations","index","indexx","x","y","push","highlightFixed","highlightDynamic","highlightPawn","moves","valid_moves","temp","clicked_piece","console","log","moved_before","move_Pawn_firstTime","pawn_color","previous_board","count","findTheHighlightedSquares","state","temp_squareColor","validCoordinates","history","can_white_castle","can_black_castle","checkForCastling","dark_Rook","dark_Knight","dark_Bishop","dark_Queen","dark_King","dark_Pawn","light_Rook","light_Knight","light_Bishop","light_Queen","light_King","light_Pawn","blank","pieces","Object","assign","Array","fill","pawnPromotions","swap","previous_i","previous_j","makeMove","validLocationsToMoveTo","instance","default_squareColor","player_turn","valid_x","valid_y","isValidMove","checkForEnPassant","canWhiteCastle","canBlackCastle","checkCastling","options","user_choice","window","prompt","toLocaleLowerCase","white","black","promotePawn","didIPutThemInCheck","findEnemyKing","enemyKing_x","enemyKing_y","allMyNextPossibleMoves","setState","prevState","board","selected_piece","value","squareColor","turn","in_check","map","value_2","Square","props","className","style","backgroundColor","onClick","src","alt","ChessBoard","this","handleClick","id","renderSquare","React","Component","TurnTracker","Check","Undo","handleUndo","NewGame","location","reload","App","bind","handleUndoClick","previous_value","validMoves","startAnalysis","slice","pop","title","href","target","rel","ReactDOM","render","document","getElementById"],"mappings":"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KAKZ2B,EAAmB,CACnBvC,MGxHW,y+FHyHXC,MAAO,QACPP,MAAO,QACPQ,KAAM,CACF,CACIS,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,GAER,CACID,GAAI,EACJC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,KAKX4B,EAAkB,CAClBxC,MIhKW,6wGJiKXC,MAAO,OACPP,MAAO,QACP6B,cAAc,EACdrB,KAAK,CACD,CACIS,EAAE,EACFC,EAAE,GAEN,CACID,EAAE,EACFC,GAAG,GAEP,CACID,GAAG,EACHC,EAAE,GAEN,CACID,GAAG,EACHC,GAAG,GAEP,CACID,GAAG,EACHC,EAAE,GAEN,CACID,EAAE,EACFC,EAAE,GAEN,CACID,EAAE,EACFC,GAAG,GAEP,CACID,EAAE,EACFC,EAAE,KAKV6B,EAAkB,CAClBzC,MKzMW,ikCL0MXC,MAAO,OACPP,MAAO,QACP6B,cAAc,EACdC,oBAAqB,CACjB,CACIb,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,GAGP,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,IAGZV,KAAM,CACF,CACIS,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,KAKZ8B,EAAmB,CACnB1C,MMjPW,qvCNkPXC,MAAO,OACPP,MAAO,QACP6B,cAAc,EACdrB,KAAM,CACF,CACIS,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,GAER,CACID,GAAI,EACJC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,KAKX+B,EAAqB,CACrB3C,MO1QW,i+EP2QXC,MAAO,SACPP,MAAO,QACPQ,KAAM,CACF,CACIS,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,GAAI,GAER,CACID,GAAI,EACJC,GAAI,GAER,CACID,EAAG,EACHC,GAAI,GAER,CACID,EAAG,EACHC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,KAKXgC,EAAqB,CACrB5C,MQlTW,yjFRmTXC,MAAO,SACPP,MAAO,QACPQ,KAAM,CACF,CACIS,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,KAKZiC,EAAoB,CACpB7C,MS1UW,q9GT2UXC,MAAO,QACPP,MAAO,QACPQ,KAAM,CACF,CACIS,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,GAER,CACID,EAAG,EACHC,EAAG,GAEP,CACID,EAAG,EACHC,GAAI,GAER,CACID,GAAI,EACJC,EAAG,GAEP,CACID,EAAG,EACHC,EAAG,KAKXkC,EAAmB,CACnB9C,MUlXW,y/FVmXXC,MAAO,OACPP,MAAO,QACP6B,cAAc,EACdrB,KAAK,CACD,CACIS,EAAE,EACFC,EAAE,GAEN,CACID,EAAE,EACFC,GAAG,GAEP,CACID,GAAG,EACHC,EAAE,GAEN,CACID,GAAG,EACHC,GAAG,GAEP,CACID,GAAG,EACHC,EAAE,GAEN,CACID,EAAE,EACFC,EAAE,GAEN,CACID,EAAE,EACFC,GAAG,GAEP,CACID,EAAE,EACFC,EAAE,KAKVmC,EAAmB,CACnB/C,MW3ZW,ytDX4ZXC,MAAO,OACPP,MAAO,QACP6B,cAAc,EACdC,oBAAqB,CACjB,CACIb,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,EAAG,GAGP,CACID,GAAI,EACJC,GAAI,GAER,CACID,GAAI,EACJC,EAAG,IAGXV,KAAM,CACF,CACIS,GAAI,EACJC,EAAG,GAEP,CACID,GAAI,EACJC,GAAI,GAER,CACID,GAAI,EACJC,EAAG,KAKXoC,EAAc,CACdhD,MAAO,GACPC,MAAO,GACPP,MAAO,GACPQ,KAAK,IAIE+C,EAAS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","file":"static/js/main.f396ed83.chunk.js","sourcesContent":["import {Piece, Move} from './initialBoard'; // importing the interfaces from the initalBoard file which defines each piece object\r\n\r\n/****************************************************************************************************/\r\n\r\nexport function willMovingHereCheckMe(board_copy:Array<Array<Piece>>, move_x:number, move_y:number, i:number, j:number) : boolean{\r\n\r\n    let pieceInvestigating = board_copy[i][j];\r\n\r\n    let currentColor = pieceInvestigating.color;\r\n\r\n    // copy of the board where we will simualte the move to the highlighted square and see if moving there will check myself\r\n    let simualtingBoard = JSON.parse(JSON.stringify(board_copy));\r\n    let copyForPawnMovementAnalysis = JSON.parse(JSON.stringify(board_copy));\r\n\r\n    // moving the clicked piece to the proposed location\r\n    simualtingBoard[move_x][move_y] = pieceInvestigating;\r\n    simualtingBoard[i][j] = {image: \"\", piece: \"\", color: \"\", move:[]};\r\n\r\n    let [king_x, king_y] = findMyKing(simualtingBoard, currentColor); \r\n\r\n    let enemyPossibleCaptureLocations = getAllAttackLocations(simualtingBoard, copyForPawnMovementAnalysis, currentColor);\r\n\r\n    for(let index = 0; index < enemyPossibleCaptureLocations.length; index++){\r\n        for(let indexx = 0 ; indexx < enemyPossibleCaptureLocations[index].length ; indexx++){\r\n            let x = enemyPossibleCaptureLocations[index][indexx].x;\r\n            let y = enemyPossibleCaptureLocations[index][indexx].y;\r\n            if(x === king_x && y === king_y){\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n\r\nfunction findMyKing(simualtingBoard:Array<Array<Piece>>, color:string) : number[] {\r\n    for (let i = simualtingBoard.length - 1; i >= 0; i--) {\r\n        for(let j = 0; j < simualtingBoard.length ; j++){\r\n            if(simualtingBoard[i][j].piece === \"King\" && simualtingBoard[i][j].color === color){\r\n                return [i, j];\r\n            }\r\n        }\r\n    }\r\n    return [0, 0]; // JUST A PLACEHOLDER TO MAKE THIS FUNCTION WORK\r\n}\r\n\r\n/****************************************************************************************************/\r\n\r\nexport function findEnemyKing(simualtingBoard:Array<Array<Piece>>, color:string) : number[] {\r\n    for (let i = simualtingBoard.length - 1; i >= 0; i--) {\r\n        for(let j = 0; j < simualtingBoard.length ; j++){\r\n            if(simualtingBoard[i][j].piece === \"King\" && simualtingBoard[i][j].color !== color){\r\n                return [i, j];\r\n            }\r\n        }\r\n    }\r\n    return [0, 0]; // JUST A PLACEHOLDER TO MAKE THIS FUNCTION WORK\r\n}\r\n\r\n/****************************************************************************************************/\r\n\r\nexport function getAllAttackLocations(simualtingBoard:Array<Array<Piece>>, copyForPawnMovementAnalysis:Array<Array<Piece>>, color:string) : Move[][] {\r\n\r\n    let enemyPossibleCaptureLocations:Move[][] = [];\r\n\r\n    for(let i = 0; i < simualtingBoard.length ; i++){\r\n        for(let j = 0; j < simualtingBoard.length; j++){\r\n            if(simualtingBoard[i][j].piece !== \"\" && simualtingBoard[i][j].color !== color){\r\n\r\n                if(simualtingBoard[i][j].piece === \"King\" || simualtingBoard[i][j].piece === \"Knight\"){\r\n                    enemyPossibleCaptureLocations.push( highlightFixed(simualtingBoard, i, j, simualtingBoard[i][j].move) );\r\n                } else if(simualtingBoard[i][j].piece === \"Bishop\" || simualtingBoard[i][j].piece === \"Rook\" || simualtingBoard[i][j].piece === \"Queen\"){\r\n                    enemyPossibleCaptureLocations.push( highlightDynamic(simualtingBoard, i, j, simualtingBoard[i][j].move) );\r\n                } else {\r\n                    enemyPossibleCaptureLocations.push( highlightPawn(simualtingBoard, copyForPawnMovementAnalysis, i, j, simualtingBoard[i][j]) );   \r\n                }\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    return enemyPossibleCaptureLocations;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a fixed pattern of movement i.e. no diagonals / no moves that extend to either end of the puzzle\r\n// applies to Pawn, Knight, King BUT Knights are the only puzzle piece that can skip over other pieces\r\nfunction highlightFixed(board_copy: Array<Array<Piece>> , i:number, j:number, moves:Move[]) : Array<Move> {    \r\n        \r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n\r\n    for(let temp = 0; temp < moves.length; temp++){ // looping through the sets of valid moves (many per piece) and changing the color of those locations in the color array to pink\r\n        move_x = i + moves[temp].x ; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n        move_y = j + moves[temp].y;\r\n        if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){ // check to ensure that we don't get a \"index out of bound\" error \r\n            \r\n            if(board_copy[move_x][move_y].piece === \"\" || board_copy[move_x][move_y].color !== board_copy[i][j].color){ // check to only highlight the pieces that are not occupied by pieces of the same color\r\n                            \r\n                    valid_moves.push(\r\n                        {\r\n                        x: move_x, \r\n                        y: move_y \r\n                        });\r\n\r\n            } \r\n        }\r\n    }\r\n\r\n    return valid_moves;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a fixed pattern of movement i.e. no diagonals / no moves that extend to either end of the puzzle\r\n// applies to Pawn, Knight, King BUT Knights are the only puzzle piece that can skip over other pieces\r\nfunction highlightPawn(board_copy: Array<Array<Piece>> , copyForPawnMovementAnalysis:Array<Array<Piece>> , i:number, j:number, clicked_piece:Piece) : Array<Move> {    \r\n\r\n    console.log(\"here\");\r\n\r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n    let moves:Array<Move> = [];\r\n\r\n    let moved_before:boolean = clicked_piece.moved_before as boolean;\r\n\r\n    if(moved_before === false){\r\n\r\n        moves = clicked_piece.move_Pawn_firstTime as Array<Move>;\r\n\r\n        // this loop handles the highlighting of the 2 squares the pawn can move up initially. notice index < 2\r\n        for(let index = 0; index < 2; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(board_copy[move_x][move_y].piece === \"\"){\r\n\r\n                valid_moves.push(\r\n                    {\r\n                    x: move_x, \r\n                    y: move_y \r\n                    });\r\n\r\n            } else {\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n        // this loop starts at 2 because the elements in the move_pawn_first_time array have this arrangement:\r\n        // [0] and [1] are for the 2 vertical squares that the pawn can move up if free, [2] and [3] are the diagonal captures a pawn can make even on its first move\r\n        for(let index = 2; index < moves.length; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){\r\n                if(board_copy[move_x][move_y].piece !== \"\" && board_copy[move_x][move_y].color !== board_copy[i][j].color){\r\n\r\n                    valid_moves.push(\r\n                        {\r\n                        x: move_x, \r\n                        y: move_y \r\n                        });\r\n                    } \r\n            }\r\n\r\n        }\r\n\r\n    } else {\r\n\r\n        // handling the ability to move up one square if free\r\n        moves = clicked_piece.move as Array<Move>;\r\n\r\n        move_x = i + moves[0].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n        move_y = j + moves[0].y;\r\n\r\n        if(board_copy[move_x][move_y].piece === \"\"){\r\n\r\n                valid_moves.push(\r\n                    {\r\n                    x: move_x, \r\n                    y: move_y \r\n                    });\r\n\r\n        }\r\n\r\n        // checking if we can highlight the corner squares if there's potential for capturing\r\n        for(let index = 1; index < moves.length; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){    \r\n\r\n                if(board_copy[move_x][move_y].piece !== \"\" && board_copy[move_x][move_y].color !== board_copy[i][j].color){\r\n\r\n                    valid_moves.push(\r\n                        {\r\n                        x: move_x, \r\n                        y: move_y \r\n                        });\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // handling the En Passant rule for pawns - TBD stupid method\r\n\r\n        let pawn_color = clicked_piece.color;\r\n\r\n        if(pawn_color === \"white\"){\r\n            if(j-1 >= 0){\r\n                if(board_copy[i][j-1].piece === \"Pawn\" && board_copy[i][j-1].color !== board_copy[i][j].color){\r\n                    let previous_board = copyForPawnMovementAnalysis;\r\n                    let previous_opponent_location = previous_board[i][j-1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i-2][j-1].piece === \"Pawn\" && previous_board[i-2][j-1].moved_before === false){\r\n\r\n                        valid_moves.push(\r\n                            {\r\n                            x: i-1, \r\n                            y: j-1 \r\n                            });\r\n    \r\n                    }\r\n                }\r\n            } \r\n            \r\n            if(j+1 < board_copy.length){\r\n                if(board_copy[i][j+1].piece === \"Pawn\" && board_copy[i][j+1].color !== board_copy[i][j].color){\r\n                    let previous_board = copyForPawnMovementAnalysis;\r\n                    let previous_opponent_location = previous_board[i][j+1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i-2][j+1].piece === \"Pawn\" && previous_board[i-2][j+1].moved_before === false){\r\n\r\n                        valid_moves.push(\r\n                            {\r\n                            x: i-1, \r\n                            y: j+1 \r\n                            });\r\n    \r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if(pawn_color === \"black\"){\r\n            if(j-1 >= 0){\r\n                if(board_copy[i][j-1].piece === \"Pawn\" && board_copy[i][j-1].color !== board_copy[i][j].color){\r\n                    let previous_board = copyForPawnMovementAnalysis;\r\n                    let previous_opponent_location = previous_board[i][j-1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i+2][j-1].piece === \"Pawn\" && previous_board[i+2][j-1].moved_before === false){\r\n\r\n                        valid_moves.push(\r\n                            {\r\n                            x: i+1, \r\n                            y: j-1 \r\n                            });\r\n\r\n                    }\r\n                }\r\n            } \r\n            \r\n            if(j+1 < board_copy.length){\r\n                if(board_copy[i][j+1].piece === \"Pawn\" && board_copy[i][j+1].color !== board_copy[i][j].color){\r\n                    let previous_board = copyForPawnMovementAnalysis;\r\n                    let previous_opponent_location = previous_board[i][j+1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i+2][j+1].piece === \"Pawn\" && previous_board[i+2][j+1].moved_before === false){\r\n\r\n                        valid_moves.push(\r\n                            {\r\n                            x: i+1, \r\n                            y: j+1 \r\n                            });\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return valid_moves;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a dynamic pattern of movement i.e. diagonals, moves that extend to either end of the puzzle\r\n// applies to Bishops, Queens, Rooks\r\n// NOTE: these pieces CANNOT skip over pieces in their proposed path \r\nfunction highlightDynamic(board_copy: Array<Array<Piece>>, i:number, j:number, moves:Move[]) : Array<Move>{    \r\n\r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n\r\n    for(let temp = 0; temp < moves.length; temp++){ // looping through the sets of valid moves (many per piece) and changing the color of those locations in the color array to pink\r\n        \r\n        for (let count = 1; count < 8; count++){ // I have to loop through multiple possibilites for each given move; this is to catch the diagonal aspect. e.g. if 1, 1 is a possible move, I need to also check if 2,2 and 3,3, etc. are valid diagonal moves\r\n            \r\n            move_x = i + count * moves[temp].x ; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + count * moves[temp].y;\r\n            \r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){ // check to ensure that we don't get a \"index out of bound\" error\r\n                \r\n                if(board_copy[move_x][move_y].piece === \"\"){  // highlighting an empty square in the piece's proposed path\r\n\r\n                    valid_moves.push(\r\n                        {\r\n                        x: move_x, \r\n                        y: move_y \r\n                        });\r\n                    \r\n                } else if (board_copy[move_x][move_y].color !== board_copy[i][j].color){ // highlighting a non-empty square that must be of the opposite color. This shows that we can capture this piece\r\n                \r\n                    valid_moves.push(\r\n                        {\r\n                        x: move_x, \r\n                        y: move_y \r\n                        });\r\n                        \r\n                    break; // breaking because we can't skip over the enemy piece that we found on our path\r\n                \r\n                } else {\r\n                    break; // we must've come across a piece of the same color in our path. Thus, we break and try a different pattern\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n    return valid_moves;\r\n}\r\n","import {Piece, Move} from './initialBoard'; // importing the interfaces from the initalBoard file which defines each piece object\r\nimport {State} from './startAnalysis';\r\nimport {willMovingHereCheckMe} from './check';\r\n/****************************************************************************************************/\r\n// function called once to initalize the chess board to the brown colors, and called to set the global variable \"default_squareColor\"\r\nexport function getColor(i : number, j : number) : string  {\r\n    if(i%2 === 0){\r\n        if(j%2 === 0){\r\n            return \"rgb(243, 218, 176)\"\r\n        } else {\r\n            return \"rgb(188, 136, 91)\"\r\n        }\r\n    } else {\r\n        if(j%2 === 0){\r\n            return \"rgb(188, 136, 91)\"\r\n        } else {\r\n            return \"rgb(243, 218, 176)\"\r\n        }\r\n    }\r\n}\r\n\r\n/****************************************************************************************************/\r\nexport function findTheHighlightedSquares(state:State, board_copy:Array<Array<Piece>>, clicked_piece : Piece, temp_squareColor: Array<Array<string>>, i:number, j:number) : Array<Move> {\r\n    \r\n    let moves; // variable used to store the set of valid moves for the piece we clicked. These moves are stored in the Piece object (see initlaBoard)\r\n    \r\n    let validCoordinates: Array<Move> = [];\r\n\r\n    // We have to consider Pawns separately because their valid moves change depending on if it's the first time the pawn is moved\r\n    if(clicked_piece.piece === \"Pawn\"){\r\n\r\n        validCoordinates = highlightPawn(board_copy, state.history, temp_squareColor, i, j, clicked_piece); // function to alter the temp_squareColor array that will be used in setState => passed and changed by reference\r\n        // an array of valid squares that we're allowed to move to is returned. this will be returned to startAnalysis to update the state's selection_piece.validCoordinates\r\n        return JSON.parse(JSON.stringify(validCoordinates));\r\n    \r\n    } else if (clicked_piece.piece === \"Bishop\" || clicked_piece.piece === \"Rook\" || clicked_piece.piece === \"Queen\"){\r\n\r\n        moves = clicked_piece.move;\r\n        validCoordinates = highlightDynamic(board_copy, temp_squareColor, i, j, moves as Move[]);\r\n        return JSON.parse(JSON.stringify(validCoordinates));\r\n    \r\n    } else if (clicked_piece.piece === \"Knight\" || clicked_piece.piece === \"King\"){\r\n\r\n        moves = clicked_piece.move;\r\n        validCoordinates = highlightFixed(state, board_copy, temp_squareColor, i, j, moves as Move[]);\r\n        return JSON.parse(JSON.stringify(validCoordinates));\r\n    \r\n    } else {\r\n        return [];\r\n    }\r\n    \r\n}\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a fixed pattern of movement i.e. no diagonals / no moves that extend to either end of the puzzle\r\n// applies to Knight and King BUT Knights are the only puzzle piece that can skip over other pieces\r\nfunction highlightFixed(state:State, board_copy: Array<Array<Piece>>, temp_squareColor: Array<Array<string>>, i:number, j:number, moves:Move[]) : Array<Move> {    \r\n        \r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n\r\n    for(let temp = 0; temp < moves.length; temp++){ // looping through the sets of valid moves (many per piece) and changing the color of those locations in the color array to pink\r\n        \r\n        move_x = i + moves[temp].x ; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n        move_y = j + moves[temp].y;\r\n        \r\n        if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){ // check to ensure that we don't get a \"index out of bound\" error \r\n            \r\n            if(board_copy[move_x][move_y].piece === \"\" || board_copy[move_x][move_y].color !== board_copy[i][j].color){ // check to only highlight the pieces that are not occupied by pieces of the same color\r\n                \r\n\r\n                if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n                    \r\n                    temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)                    \r\n                    // if we find a valid square that we can potentially move to, we'll add it valid_moves which will be used to update the state's \"selected_piece{validCoordinates}\"\r\n                    // this validCoordinates will be used as the comparison point if our next click is on an empty square. That square's (x,y) will be compared to the coordinates in validCoordinates\r\n                    valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                }\r\n\r\n            } \r\n        }\r\n    }\r\n\r\n    checkForCastling(state, board_copy, i, j, temp_squareColor, valid_moves);\r\n\r\n    return valid_moves;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\nfunction checkForCastling(state:State, board_copy:Array<Array<Piece>>, i:number, j:number, temp_squareColor:Array<Array<string>>, valid_moves:Array<Move>){\r\n    \r\n    let can_castle = board_copy[i][j].color === \"white\" ? state.can_white_castle[state.can_white_castle.length - 1]: state.can_black_castle[state.can_black_castle.length - 1]; \r\n    if(can_castle && board_copy[i][j].piece === \"King\" && board_copy[i][j].moved_before === false){\r\n        if(board_copy[i][7].piece === \"Rook\" && board_copy[i][7].moved_before === false){\r\n            for(let index = j+1; index < 7 ; index++){\r\n                if(board_copy[i][index].piece === \"\"){\r\n                    if(!willMovingHereCheckMe(board_copy, i, index, i, j)){\r\n                        if(index === 6){\r\n                            temp_squareColor[i][index] = \"red\";\r\n                            valid_moves.push({x:i, y:index});\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        \r\n            if(board_copy[i][0].piece === \"Rook\" && board_copy[i][0].moved_before === false){\r\n                for(let index = j-1; index > 0 ; index--){\r\n                    if(board_copy[i][index].piece === \"\"){\r\n                        if(!willMovingHereCheckMe(board_copy, i, index, i, j)){\r\n                            if(index === 1){\r\n                                temp_squareColor[i][index + 1] = \"red\";\r\n                                valid_moves.push({x:i, y:index + 1});\r\n                            }\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a fixed pattern of movement i.e. no diagonals / no moves that extend to either end of the puzzle\r\n// applies to Pawn, Knight, King BUT Knights are the only puzzle piece that can skip over other pieces\r\nfunction highlightPawn(board_copy: Array<Array<Piece>> , history : Array<Array<Array<Piece>>> , temp_squareColor: Array<Array<string>>, i:number, j:number, clicked_piece:Piece) : Array<Move> {    \r\n\r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n    let moves:Array<Move> = [];\r\n\r\n    let moved_before:boolean = clicked_piece.moved_before as boolean;\r\n\r\n    if(moved_before === false){\r\n\r\n        moves = clicked_piece.move_Pawn_firstTime as Array<Move>;\r\n\r\n        // this loop handles the highlighting of the 2 squares the pawn can move up initially. notice index < 2\r\n        for(let index = 0; index < 2; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(board_copy[move_x][move_y].piece === \"\"){\r\n\r\n                if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                    temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)                    \r\n                    // if we find a valid square that we can potentially move to, we'll add it valid_moves which will be used to update the state's \"selected_piece{validCoordinates}\"\r\n                    // this validCoordinates will be used as the comparison point if our next click is on an empty square. That square's (x,y) will be compared to the coordinates in validCoordinates\r\n                    valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                break;\r\n            \r\n            }\r\n\r\n        }\r\n\r\n        // this loop starts at 2 because the elements in the move_pawn_first_time array have this arrangement:\r\n        // [0] and [1] are for the 2 vertical squares that the pawn can move up if free, [2] and [3] are the diagonal captures a pawn can make even on its first move\r\n        for(let index = 2; index < moves.length; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){\r\n\r\n                if(board_copy[move_x][move_y].piece !== \"\" && board_copy[move_x][move_y].color !== board_copy[i][j].color){\r\n\r\n                    if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                        temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)                    \r\n                        // if we find a valid square that we can potentially move to, we'll add it valid_moves which will be used to update the state's \"selected_piece{validCoordinates}\"\r\n                        // this validCoordinates will be used as the comparison point if our next click is on an empty square. That square's (x,y) will be compared to the coordinates in validCoordinates\r\n                        valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                    }\r\n\r\n                } \r\n            }\r\n\r\n        }\r\n\r\n    } else {\r\n\r\n        // handling the ability to move up one square if free\r\n        moves = clicked_piece.move as Array<Move>;\r\n\r\n        move_x = i + moves[0].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n        move_y = j + moves[0].y;\r\n\r\n        if(board_copy[move_x][move_y].piece === \"\"){\r\n\r\n            if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)                    \r\n                    // if we find a valid square that we can potentially move to, we'll add it valid_moves which will be used to update the state's \"selected_piece{validCoordinates}\"\r\n                    // this validCoordinates will be used as the comparison point if our next click is on an empty square. That square's (x,y) will be compared to the coordinates in validCoordinates\r\n                    valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                }\r\n\r\n        }\r\n\r\n        // checking if we can highlight the corner squares if there's potential for capturing\r\n        for(let index = 1; index < moves.length; index++){\r\n\r\n            move_x = i + moves[index].x; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + moves[index].y;\r\n\r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){    \r\n\r\n                if(board_copy[move_x][move_y].piece !== \"\" && board_copy[move_x][move_y].color !== board_copy[i][j].color){\r\n\r\n                    if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                        temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)                    \r\n                        // if we find a valid square that we can potentially move to, we'll add it valid_moves which will be used to update the state's \"selected_piece{validCoordinates}\"\r\n                        // this validCoordinates will be used as the comparison point if our next click is on an empty square. That square's (x,y) will be compared to the coordinates in validCoordinates\r\n                        valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // handling the En Passant rule for pawns - TBD stupid method\r\n\r\n        let pawn_color = clicked_piece.color;\r\n\r\n        if(pawn_color === \"white\"){\r\n\r\n            if(j-1 >= 0){ // checking if the square immediately to our left is a pawn of the opposite color\r\n                if(board_copy[i][j-1].piece === \"Pawn\" && board_copy[i][j-1].color !== board_copy[i][j].color){\r\n                    let previous_board = history[history.length - 2];\r\n                    let previous_opponent_location = previous_board[i][j-1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i-2][j-1].piece === \"Pawn\" && previous_board[i-2][j-1].moved_before === false){\r\n                        \r\n                        if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                            temp_squareColor[i-1][j-1] = \"pink\";                    \r\n                            valid_moves.push({ x: i-1, y: j-1 });\r\n\r\n                        }\r\n                    }\r\n                }\r\n            } \r\n            \r\n            if(j+1 < board_copy.length){ // checking if the square immediately to our right is a pawn of the opposite color\r\n                if(board_copy[i][j+1].piece === \"Pawn\" && board_copy[i][j+1].color !== board_copy[i][j].color){\r\n                    let previous_board = history[history.length - 2];\r\n                    let previous_opponent_location = previous_board[i][j+1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i-2][j+1].piece === \"Pawn\" && previous_board[i-2][j+1].moved_before === false){\r\n                        \r\n                        if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                            temp_squareColor[i-1][j+1] = \"pink\";                    \r\n                            valid_moves.push({ x: i-1, y: j+1 });\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if(pawn_color === \"black\"){\r\n            if(j-1 >= 0){\r\n                if(board_copy[i][j-1].piece === \"Pawn\" && board_copy[i][j-1].color !== board_copy[i][j].color){\r\n                    let previous_board = history[history.length - 2];\r\n                    let previous_opponent_location = previous_board[i][j-1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i+2][j-1].piece === \"Pawn\" && previous_board[i+2][j-1].moved_before === false){\r\n                        \r\n                        if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                            temp_squareColor[i+1][j-1] = \"pink\";                    \r\n                            valid_moves.push({ x: i+1, y: j-1 });\r\n\r\n                        }\r\n                    }\r\n                }\r\n            } \r\n            \r\n            if(j+1 < board_copy.length){\r\n                if(board_copy[i][j+1].piece === \"Pawn\" && board_copy[i][j+1].color !== board_copy[i][j].color){\r\n                    let previous_board = history[history.length - 2];\r\n                    let previous_opponent_location = previous_board[i][j+1];\r\n                    if(previous_opponent_location.piece === \"\" && previous_board[i+2][j+1].piece === \"Pawn\" && previous_board[i+2][j+1].moved_before === false){\r\n                        \r\n                        if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                            temp_squareColor[i+1][j+1] = \"pink\";                    \r\n                            valid_moves.push(\r\n                                {\r\n                                x: i+1, \r\n                                y: j+1 \r\n                                });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return valid_moves;\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n// function to find the spots to highlight on the puzzle for pieces with a dynamic pattern of movement i.e. diagonals, moves that extend to either end of the puzzle\r\n// applies to Bishops, Queens, Rooks\r\n// NOTE: these pieces CANNOT skip over pieces in their proposed path \r\nfunction highlightDynamic(board_copy: Array<Array<Piece>>, temp_squareColor: Array<Array<string>>, i:number, j:number, moves:Move[]) : Array<Move>{    \r\n\r\n    let move_x:number;\r\n    let move_y:number;\r\n    let valid_moves: Array<Move> = [];\r\n\r\n    for(let temp = 0; temp < moves.length; temp++){ // looping through the sets of valid moves (many per piece) and changing the color of those locations in the color array to pink\r\n        \r\n        for (let count = 1; count < 8; count++){ // I have to loop through multiple possibilites for each given move; this is to catch the diagonal aspect. e.g. if 1, 1 is a possible move, I need to also check if 2,2 and 3,3, etc. are valid diagonal moves\r\n            \r\n            move_x = i + count * moves[temp].x ; // moves is an array of \"Moves\"; see initialBoard for interface. it's an object with x and y representing the alteration to be made to the array location\r\n            move_y = j + count * moves[temp].y;\r\n            \r\n            if(move_x < 8 && move_x >= 0 && move_y < 8 && move_y >= 0){ // check to ensure that we don't get a \"index out of bound\" error\r\n                \r\n                if(board_copy[move_x][move_y].piece === \"\"){  // highlighting an empty square in the piece's proposed path\r\n                    \r\n                    if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                        temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)\r\n                        valid_moves.push({ x: move_x, y: move_y });\r\n                    \r\n                    }\r\n\r\n                } else if (board_copy[move_x][move_y].color !== board_copy[i][j].color) { // highlighting a non-empty square that must be of the opposite color. This shows that we can capture this piece\r\n                \r\n                    if( !willMovingHereCheckMe(board_copy, move_x, move_y, i, j) ){\r\n\r\n                        temp_squareColor[move_x][move_y] = \"pink\"; // changing the location's color to pink (array changed by reference; this changes the array back in startAnalysis)\r\n                        valid_moves.push({ x: move_x, y: move_y });\r\n\r\n                    }\r\n\r\n                    break;// breaking because we can't skip over the enemy piece that we found on our path\r\n\r\n                } else {\r\n\r\n                    break; // we must've come across a piece of the same color in our path. Thus, we break and try a different pattern\r\n                \r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    return valid_moves;\r\n}\r\n\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARpSURBVGiB7Zo/bFtVFMZ/x7EhUdN2cFSkDMSCdEnKgkSH0IAZACkgAgpL2yhCDGz8UZNgRYINhpQgQAgQIwNiARRRJJOJAVhAuEhtBUIijhpRZJyAGpw4jRMfhmcjU/XZ78XnvbhuPunIkt/1ud/ne8699517RVW5lRDZawJhY19wu2NfcLtjTwSLSEJEBkUk9P5D7VBEhkXkZyALXATyIvJcmBxQ1VAMuB8oAXoDS4XFQ8LaeIjIRWDQ5XEJSKjqlaB5hBLSItKLu1iAGPBgGFzCyuHbPbTpDJwFIQlW1Szwe4Nm34XBJcxZ+qU6z95T1V/DIBGm4C+Bj3Fm5Vr8CMyGxiKE5agTOAP8wY2XJAWKwDtAb+B8AhZ7J3C+jtDr7W/g4ZtSMHACyPkQW7Vt4PmbSjDwLHBtF2Jr7UOgo+UFA48A5SbFVu31lhYM9ABXGgmZnZ3VdDqtkUikkeAdYLiVBc97GblsNquqqn19fV5GeQk4bMXRbB0WkceAUY9t//fZAH3AK7smdh2iVo6A024PRISpqSkGB533h56eHgDm5uYoFAqsr68zMzPD2tqam4uTIvKyVsKoKRiFchfwDy5hGY/HdXt7W+thbGysUWifsOBqNcKPAt1uD1dXV0kmk/T39wPOyMbjcaanp1lZWSGfz5NOpxv18TTwbdNMjUb4DD6Wm6WlJVVVTSQSfpaoL1pp0rrNT+OtrS0AyuVyYH24wSqkY34ap1IpBgYGWF5eDqwPVxiF9DPY7Kzq2UetFNLncDb9QWLewomJYFVdBb628OWCIrBg4ciy4nEW56UhCLypqhsmnizyoiaXp7HP3XNAxIyjpeCK6LNAaWhoSHO5nG5ubvqyjY0NnZycrIr9Cjhkyc9yL11FCjja2dn5ZDwep6Ojw9ePVZVoNAqwCJxSVdcN9m5gftQiIi8CbwNEo9Eqec8ol8v/bUyAeVV9ypSgcTjfjTOjWubwaUuO1nXpUeyPTE5aOjPN4fHx8dGRkREiEbv/MZPJPCQiola5ZxjOsYWFhS01RrFY1O7u7geseFqOcGxiYiKWTCa9lm48IZPJUCgUDlj5M52lRSSPU7m0xjFVvWThyHrS+tzYH8AlwO5k0So3KpESAV6gTn3Lh5WBDzDeaQVyx0NEDgKP49ShhnHC3EtirwEXgM+AT1XVV4XAE7fdChZnZuoFjuBUI2rtQOX7OyqfvTiHa0dc3G3gFOiywJ8VywFXcS681NpV4LKqlnbF26tgETkOPAHcC9wFJPB2dyMI7OBcoVgEfgLeVdVFT7/0kJeHgE8IvoTTjJWAV6kMYF09DcR2Ad+0gCCvlgbizQh+vwVE+LXzzey0Cg2e+8VvwA/A9zhL133AceAYdvv6Qr29d8NJS0ROAW/gzLwXgF+AyzWWw1lyokBHxQRnYqnaNpBT1b9c+ujCOSWs9VH9A2p97AAHK22rdhS4BzgMvAW8pqrXXPUEsQ7vBby+UbWNYK/YvxHf7tgX3O645QT/Cym/GLJbVZClAAAAAElFTkSuQmCC\"","import darkBishop from '../src/full rez pics/darkBishop.png';\r\nimport lightBishop from '../src/full rez pics/lightBishop.png';\r\nimport darkKing from '../src/full rez pics/darkKing.png';\r\nimport lightKing from '../src/full rez pics/lightKing.png';\r\nimport darkKnight from '../src/full rez pics/darkKnight.png';\r\nimport lightKnight from '../src/full rez pics/lightKnight.png';\r\nimport darkPawn from '../src/full rez pics/darkPawn.png';\r\nimport lightPawn from '../src/full rez pics/lightPawn.png';\r\nimport darkQueen from '../src/full rez pics/darkQueen.png';\r\nimport lightQueen from '../src/full rez pics/lightQueen.png';\r\nimport darkRook from '../src/full rez pics/darkRook.png';\r\nimport lightRook from '../src/full rez pics/lightRook.png';\r\n\r\nexport interface Move {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface Piece {\r\n    image: string;\r\n    piece: string;\r\n    color: string; // optional because blank squares won't have a piece color element\r\n    moved_before?: boolean; // only applies to pawns because their moving options change as the game progressess\r\n    move: Move[]; \r\n    // an array of the type \"Move\", where each Move is an object with the x and y that define each chess piece's moves\r\n    // cool thing is that the property \"move\" can be of variable length due to this definition \"Move[]\"\r\n    // this is important because some chess pieces have way more possible moves than others  \r\n    move_Pawn_firstTime?: Move[];\r\n}\r\n\r\nlet dark_Rook:Piece = {\r\n    image: darkRook,\r\n    piece: \"Rook\",\r\n    color: \"black\",\r\n    moved_before: false,\r\n    move: [\r\n        {\r\n            x: 0,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        },\r\n    ]\r\n};\r\n\r\nlet dark_Knight:Piece = {\r\n    image: darkKnight,\r\n    piece: \"Knight\",\r\n    color: \"black\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 2\r\n        },\r\n        {\r\n            x: -2,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -2,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -2\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -2\r\n        },\r\n        {\r\n            x: 2,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 2,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 2\r\n        },\r\n    ]\r\n};\r\n\r\nlet dark_Bishop:Piece = {\r\n    image: darkBishop,\r\n    piece: \"Bishop\",\r\n    color: \"black\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        },\r\n    ]\r\n};\r\n\r\nlet dark_Queen:Piece = {\r\n    image: darkQueen,\r\n    piece: \"Queen\",\r\n    color: \"black\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        }\r\n    ]\r\n};\r\n\r\nlet dark_King:Piece = {\r\n    image: darkKing,\r\n    piece: \"King\",\r\n    color: \"black\",\r\n    moved_before: false,\r\n    move:[\r\n        {\r\n            x:0,\r\n            y:1\r\n        },\r\n        {\r\n            x:0,\r\n            y:-1\r\n        },\r\n        {\r\n            x:-1,\r\n            y:0\r\n        },\r\n        {\r\n            x:-1,\r\n            y:-1\r\n        },\r\n        {\r\n            x:-1,\r\n            y:1\r\n        },\r\n        {\r\n            x:1,\r\n            y:0\r\n        },\r\n        {\r\n            x:1,\r\n            y:-1\r\n        },\r\n        {\r\n            x:1,\r\n            y:1\r\n        },\r\n    ]\r\n};\r\n\r\nlet dark_Pawn:Piece = {\r\n    image: darkPawn,\r\n    piece: \"Pawn\",\r\n    color: \"black\",    \r\n    moved_before: false,\r\n    move_Pawn_firstTime: [\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        }, \r\n        {\r\n            x: 2,\r\n            y: 0\r\n        },\r\n        // the next 2 elements are here because a pawn can also capture diagonally on its firs move \r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        }\r\n    ],\r\n    move: [ // tbd: the first element in move is the ability of the pawn to move forward one step. The other 2 are the ability to capture\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        }\r\n    ]\r\n};\r\n\r\nlet light_Rook:Piece = {\r\n    image: lightRook,\r\n    piece: \"Rook\",\r\n    color: \"white\",\r\n    moved_before: false,\r\n    move: [\r\n        {\r\n            x: 0,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        },\r\n    ]\r\n};\r\n\r\nlet light_Knight:Piece = {\r\n    image: lightKnight,\r\n    piece: \"Knight\",\r\n    color: \"white\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 2\r\n        },\r\n        {\r\n            x: -2,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -2,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -2\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -2\r\n        },\r\n        {\r\n            x: 2,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 2,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 2\r\n        },\r\n    ]\r\n};\r\n\r\nlet light_Bishop:Piece = {\r\n    image: lightBishop,\r\n    piece: \"Bishop\",\r\n    color: \"white\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        },\r\n    ]\r\n};\r\n\r\nlet light_Queen:Piece = {\r\n    image: lightQueen,\r\n    piece: \"Queen\",\r\n    color: \"white\",\r\n    move: [\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: 1\r\n        },\r\n        {\r\n            x: 0,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: 1,\r\n            y: 0\r\n        }\r\n    ]\r\n};\r\n\r\nlet light_King:Piece = {\r\n    image: lightKing,\r\n    piece: \"King\",\r\n    color: \"white\",\r\n    moved_before: false,\r\n    move:[\r\n        {\r\n            x:0,\r\n            y:1\r\n        },\r\n        {\r\n            x:0,\r\n            y:-1\r\n        },\r\n        {\r\n            x:-1,\r\n            y:0\r\n        },\r\n        {\r\n            x:-1,\r\n            y:-1\r\n        },\r\n        {\r\n            x:-1,\r\n            y:1\r\n        },\r\n        {\r\n            x:1,\r\n            y:0\r\n        },\r\n        {\r\n            x:1,\r\n            y:-1\r\n        },\r\n        {\r\n            x:1,\r\n            y:1\r\n        },\r\n    ]\r\n};\r\n\r\nlet light_Pawn:Piece = {\r\n    image: lightPawn,\r\n    piece: \"Pawn\",\r\n    color: \"white\",\r\n    moved_before: false,\r\n    move_Pawn_firstTime: [\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        }, \r\n        {\r\n            x: -2,\r\n            y: 0\r\n        },\r\n        // the next 2 elements are here because a pawn can also capture diagonally on its firs move \r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        }\r\n    ],\r\n    move: [ // tbd: the first element in move is the ability of the pawn to move forward one step. The other 2 are the ability to capture\r\n        {\r\n            x: -1,\r\n            y: 0\r\n        },\r\n        {\r\n            x: -1,\r\n            y: -1\r\n        },\r\n        {\r\n            x: -1,\r\n            y: 1\r\n        }\r\n    ]\r\n};\r\n\r\nlet blank:Piece = {\r\n    image: \"\",\r\n    piece: \"\",\r\n    color: \"\",\r\n    move:[]\r\n}\r\n\r\n// used to initialize the board in the App component index.js\r\nexport let pieces = [\r\n    [Object.assign({}, dark_Rook), Object.assign({}, dark_Knight), Object.assign({}, dark_Bishop), dark_Queen, dark_King, Object.assign({}, dark_Bishop), Object.assign({}, dark_Knight), Object.assign({}, dark_Rook)],\r\n    new Array(8).fill(Object.assign({}, dark_Pawn)),\r\n    new Array(8).fill(blank),\r\n    new Array(8).fill(blank),\r\n    new Array(8).fill(blank),\r\n    new Array(8).fill(blank),\r\n    new Array(8).fill(Object.assign({}, light_Pawn)),\r\n    [Object.assign({}, light_Rook), Object.assign({}, light_Knight), Object.assign({}, light_Bishop), light_Queen, light_King, Object.assign({}, light_Bishop), Object.assign({}, light_Knight), Object.assign({}, light_Rook)],\r\n];\r\n\r\n// options for the user to promote the pawn when able to. used in move.ts in promotePawn()\r\nexport let pawnPromotions = {\r\n    \"white\": {\r\n        \"bishop\": light_Bishop,\r\n        \"queen\": light_Queen,\r\n        \"rook\": light_Rook,\r\n        \"knight\": light_Knight\r\n    },\r\n    \"black\": {\r\n        \"bishop\": dark_Bishop,\r\n        \"queen\": dark_Queen,\r\n        \"rook\": dark_Rook,\r\n        \"knight\": dark_Knight\r\n    }\r\n};","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJSSURBVGiB7ZqxixNBFMa/b/HOFBGbSDRgoRCQK01IndrG1j/BI0QQ7JLG2sIg5AQ7QbCystByIYVFKq1sUh0kmyKolWE37rPwxDOG252ZzcabnR+8YsObt+/bmXkzO1mKCIqEt+sE8sYJth0n2HacYNtxgm1HWzDJEsn3JGWDHZGkgr+Q/ETyyob7HJKM0/onIiJaBqANQM6wq4r+AuD+hvsEKv5JdkH5CaXnLslvp64PUrRpkry39lspw5y22sN5mHIPu6JlO+ddMJNd/sZE8CXf97VrgKnN53N4nnddNWnqnniQ3G+1Wp9rtdoNrQCGLBaLr6PR6KaIfFFqaPKUAewBeIH8q/M7AJd1ctbu4dOQfADgab/f95rNpnG8TUynU3Q6HYjIAMAjEfmhEyeTjYeIPCO5H0XRk+VymUXIfwjDECLySkQeGgXKqoggn42I8kbDbTx2nUDeOMG24wTbjhNsO06w7TjBtuME206WB/EXG40G6vV6hiH/EAQBfN8vGwfK8H34te/7si1ms5mQ/GicZ0ZibwEIkc951h2TXI2HNMlSpVJ5MxgM9spl8xF3FnEco9frvSR5W0SOdWJkMYffrlargzAMsa3zrN9EUYQwDCsAPpCsi8h31RjGp5YkAwBVoyB6XBORQLVR4Zalwgk2nsPVatVrt9tY+8Jhq4zHY0wmE73GGkvQIYAYJ8tEt9s1X2QVGQ6H60vVEU7qUZIpF60dFqkkUhWxws1hJ9h2dAQ/xq9C8T/xHMA8jWMm/w+fJ9yQth0n2HacYNspnOCf287BmtabMhEAAAAASUVORK5CYII=\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKaSURBVGiB7Zo9axVBFIafNyYoGhSNYFDUoI1CGtEgooIo/oGAhWApWlhoivgLgp32tlqJBEEsBMXGr0ILkYiVhRaCICL4gUXisbi5QaIkOzvnzL25975wujnvnIezOzs7uzIzukl9rS6gtHrAna4ecKerB9zp6jrg/lZMKmknMAbsAF4DL83sa5HJzaxYACPAA8AWxSxwBVgdXYNKbS0lHQbuA4NLDJsBDpnZ96g6itzDkgaBGywNCzAKXI2spdSiNQnsqjj2nKR9UYWUAj4SPL6ySgGndmzFd/hn8PjKKgX8Jnh8ZZUCvpMw9jdwN6qQcGBJJ4GphJQ+YFrSlpB6IjcekvYAL1j++fs/PQaOm9msZ01hHZY0AExTDxbgKI3tpqvCOizpDHAz0+YXsN3MPjuUBMTewxcdPNYA5x18FhQCLGkDcMDJ7oSTDxDX4ar75ira7egVBrzN0WtYkrzMooDfOnrNmOPKGgJsZu+AT052z518gNhV+qmTzzMnHyAW+JGDxxzwxMFnQZHA12lsD3N02cw+eBSzoOBTymHgI/+eUlaJmxE1Re6l1wIXgE01LY5JOuVYUkNBnd0LvKdeZxfHPRzPqyNgtzrCNuMW8y86bQUMrAdeOcM241pbAQMDwMMg2GZMtBPwVDCs0TjvGms5MI1TjS8FgA24nVOr12PpLLDRyWs5jUuq/cqYDSypH7iU65OgPmCidrbD5XyaMpfy3/EDGGrVJT3p4JGq5i4uWVnAkkYI/PC1jMbrJOV2+GBmfo5GJa1LTVrJwKuA/alJucCjmfm5Sp4/F3goMz9XyfP3gBO1OTM/V8nz1wae/zqYvEo6K3k7m/Pr4RytewY39S01odifeO2irvubtgfc6eoBd7q6DvgP/gH4mMhDFawAAAAASUVORK5CYII=\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMiSURBVGiB7ZqxTxNRHMc/P2jC2dDCYmhtB8cuJgQaWQwFRx1kdHAQHCr/ghOyMLAQBnRhI4Q4MTBoTEzYJDQhONIOGG3aktCQGHFo6HOAMyBX2nv3oHq9T/JLmrv3fvf73nv37t7vV1FK0Ul0tTuAmyYQ7HcCwX4nEOx3AsF+R1uwiFgi8l5ElIMtiYi4aK9E5IuI3Ha4zrSI1Ftt3xSllJYBY4C6wmIu2yvgpcN1ym7aNzPPUzqTyVxwODAwYJ96IiJPbQMeOrVXSpHNZu0+6fN9zvpZAKVSyam9a0LaPRvQ399PpVIBeNvo/BXHXpzZBXp6erAsy0h8xgWvr68zOztLvV6/dM6yLObn5y8dn5mZ4fj4mIODA0efU1NTjjdKB+OCU6kUq6urrvpYlsXi4qLpUBzxLLhcLrO2tmYilpbZ29vT7+xhlX5G81X3um3Zbdyim/EQkTCQB+6Ew2HGx8fp7e3V8tUqtVqNzc1NDg8PAX4AQ0qpgisnuiN8dqP6gM+ASiaTKp/Pq+vi6OhIjYyM2CO7D9zViVl7hG1EpA/4AIwkk0nm5uYIhYyvhSwsLLC1tQXwFRhTSu3r+PEsGP6I/hSNRoeGh4fPf3wYoVqtsru7S6VSKQIPdMUC3qb0X9P7MaAymYzx6ZzNZu2p/MprnCZ3Sz8N+mpE1auDYHvodwLBficQ7HcCwX4nEOx3AsF+p+MEm9yp9wDs7OwwMTFh0C3kcjn7Z8SrL5OCnwOk02kmJycNuoVIJMLKygqcJg4vJ7bdYGjznwJqXV1dant723gCoFQqqWg0aicBHnmJ1fMIi4gFvANCg4ODFAoFCgV3icRWGB0dZWNjA2BZRO4rpb5pOTIwuh+54Xy0iHwHbrVlhIF7AIlEgu7ubgPurqZYLHJycpLgNEX8y21/Y4tWLpcjFouZcteQWCxmVye16Lj3cMcJ1lmkpoE67S+knbclzooKzcx15UFEyoDZ0oIZ4kqpcrNG2lP6/H8u2mluyzod9wxrv5bi8bjJOG4MnRF+zelC8S/xBmjp5WykXPo/0XHPcCDY7wSC/U4g2O/8BtFWHbaczITCAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASLSURBVGiB7ZrLS2NnGIefL6YJEuM4GaOiUvDCgJIKI0Y7KFJ3BSm00j9gil1ULbRi+1cUV92U7gahSLvUzeAiVG3QCoOggxmvgRlRY2uKSLSivl3oV2JJgyfnYrw8EDgh3+X35P3ycc7JUSLCXcJ13QGc5l74tnMvfNu5F77t3Dlh93VMqpQKAmGgEVgGfheRbUcmFxHHXkAx8CMgGV4/AaV2Z1BOnVoqpaqAKPCux+Ohra2NUChELBZjZmaGw8NDgF2gXURWbAviYHVfANLS0iJLS0uSTjwel87OTl3pKFBgWw6HZD8BJBAIyNbWlmQimUxKZWWllv7MrixO7dIdAAMDA1RUVGRsUFJSwtDQ0KX2duCU8BOAcDictVHa50/sCuKUcArg5OQka6PT01N9eGRXEKeEXwFMTExkbRSJRPRhzLYkDm1a7wPi8XgkHo9n3LR2d3fF7/frTevDG7tpKaUeA88BPB4P8Xg8Y7u3b9/idv974veDUsqe37HNlS0GXgMSCoUkFotlrK5mY2NDwuGwrvImUGZ5JpuFfwakqalJDg4Osspqjo6OpKOjQ0tP3Bhhzi8MpKioSNbW1q4kq0kkElJaWqqlO6zMZedv+EuA3t5eamtrDXUMBoP09/frt19ZmsrGCq8DMj8/b6i6ms3NTV3hPStz2XK1pJRyA0cul6sglUrh9XpzGicQCJBMJgECIpK0IptdS7oMKCgpKclZFs6FL6iyIhRg65L+A5CNjY2clvTe3p4opQQ4BgqtymXnpjUDMD09nVPnaDSqv7iXInJoVSg7haMAk5OTOXWemprSh79ZlOccG5d0OyBer1dmZ2cNLedYLCbFxcV6l/7I0lx2CV9Ifw9IdXW17OzsXEl2f39fGhoatOwvlmeyWdgNRADp7OyU4+PjrLJnZ2fS09OjZReBohsjzPn+8AXwJyBut1vGxsayCkejUfF6vVr4L+BrwJ33wsBDYPYiuHR1dcni4mJWWc3q6qp0d3en369eACryVhjwAr8CUlVVJaOjo1cS/S/j4+NSV1enpV8C/rwTBhQwqjeqN2/e5CSrSSQSUl9fr6VfAO/km/B3gDx48EAWFhZMyWpWV1elrKxMSz/PG2Ggh4v7VpFIxBJZzdzcnPh8Pi39eb4IzwEyPDxsqaxmZGREC78GXNcqDHzAxV8pV72VY5STkxOpqanR0h/nmtWqc+lv4PyvFJ/PZ9GQlykoKGBwcPDSfDlhQXUbgbPCwkJJJBK2VFdzcHAggUBAV/npdVV4CFDPnj0jGAxaMNz/4/P56Ovr02+/zWkQCyq8A8jy8rKt1dVsb2+Ly+US4G/AazivSdk6QCorKx2R1TQ2Nupl3WY0s9kl/RSgtbXV5DDGSJuvzWhfs8LvATQ3N5scxhhp84WM9jUrXApQXl5uchhjpM33yGhfs8KP4NLtVEdIm8+wsKkb8UqpaaC9trYWv9+f8zhGSaVSrKysALwSEUPL2uyTeA8B1tfXTQ5jbn4jmBX+lPML/usi+0MjGXDsSbx84c49TXsvfNu5F77t3DnhfwDnGIncxPZT9AAAAABJRU5ErkJggg==\"","import {pawnPromotions} from './initialBoard';\r\nimport {Piece, Move} from './initialBoard'; // importing the interfaces from the initalBoard file which defines each piece object\r\n/****************************************************************************************************/\r\n// swapping the piece with the valid destination\r\nexport function swap(board_copy : Array<Array<Piece>>, i:number, j:number, previous_i: number, previous_j:number){\r\n    \r\n    let temp = board_copy[i][j];\r\n\r\n    if(temp.piece === \"\"){ // just moving a piece to a valid empty square\r\n        board_copy[i][j] = board_copy[previous_i][previous_j];\r\n        board_copy[previous_i][previous_j] = temp;\r\n    } else { // capturing a piece\r\n        board_copy[i][j] = board_copy[previous_i][previous_j];\r\n        board_copy[previous_i][previous_j] = {image: \"\", piece: \"\", color: \"\", move:[]}; // swap locations and turn the opposing piece to just an empty square\r\n    }\r\n\r\n}\r\n\r\n/****************************************************************************************************/\r\n// this function handles the promotion of the pawn when we try to move it to an empty square at the top or bottom edge of the board\r\nexport function promotePawn(board_copy:Array<Array<Piece>>, i:number, j:number, previous_i:number, previous_j:number){\r\n\r\n    if(board_copy[i][j].piece === \"Pawn\" && (i === board_copy.length - 1 || i === 0) ){\r\n\r\n        let options: any; // will store an object of objects (see pawnpromotions in ./initialboard.ts)\r\n        let user_choice:string | null;\r\n    \r\n        while(true){\r\n            // when we move the pawn to an empty square at the edge, we prompt the user to type in the piece they want the pawn to be promoted to\r\n            user_choice = window.prompt(\"What would you like the pawn to be promoted to?\\nChoose from a bishop, queen, rook, or knight.\")\r\n            user_choice = (user_choice as string).toLocaleLowerCase()\r\n            if(user_choice === \"rook\" || user_choice === \"queen\" || user_choice === \"knight\" || user_choice === \"bishop\"){\r\n                break;\r\n            }\r\n        }\r\n    \r\n        if(board_copy[i][j].color === \"white\"){\r\n            options = pawnPromotions.white;\r\n        } else {\r\n            options = pawnPromotions.black;\r\n        }\r\n   \r\n        // switching out the pawn with the piece we selected.\r\n        board_copy[i][j] = options[user_choice as string];    \r\n   \r\n    }\r\n\r\n}\r\n/****************************************************************************************************/\r\n// function to check if the proposed move is valid. It compares the (x,y) of the clicked square to the valid set of squares for the previously selected pieces, which is stored in state.validCoordinates \r\nexport function isValidMove(i:number, j:number, validLocationsToMoveTo: Array<Move>) : boolean {\r\n    for(let index = 0; index < validLocationsToMoveTo.length; index++){\r\n        let valid_x = validLocationsToMoveTo[index].x;\r\n        let valid_y = validLocationsToMoveTo[index].y;\r\n        if(valid_x === i && valid_y === j){\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","import {Piece, Move} from './initialBoard'; // importing the interfaces from the initalBoard file which defines each piece object\r\nimport {State} from './startAnalysis';\r\nimport {swap, promotePawn, isValidMove} from './sharedMoveLogic';\r\nimport {findEnemyKing, getAllAttackLocations} from './check';\r\n/****************************************************************************************************/\r\n// function to analyze if the location the user clicked is a valid move for the piece they previously clicked\r\nexport function makeMove(board_copy : Array<Array<Piece>>, i:number, j:number, previous_i: number, previous_j:number, \r\n    validLocationsToMoveTo: Array<Move>, instance:any, default_squareColor:Array<Array<string>>, player_turn: string, state:State){\r\n\r\n    let isValid:boolean = isValidMove(i, j, validLocationsToMoveTo);\r\n    \r\n    if(isValid){\r\n        \r\n        // check if we're tyring to capture a pawn through en passant \r\n        checkForEnPassant(board_copy, i, j, previous_i, previous_j, validLocationsToMoveTo);\r\n\r\n       // castling\r\n       let canWhiteCastle:boolean = true;\r\n       let canBlackCastle:boolean = true;\r\n\r\n       if(board_copy[previous_i][previous_j].piece === \"King\" && board_copy[i][j].piece === \"\" && board_copy[previous_i][previous_j].moved_before === false && (canBlackCastle || canWhiteCastle)){\r\n           checkCastling(board_copy, i, j, previous_i, previous_j, validLocationsToMoveTo);\r\n           board_copy[previous_i][previous_j].moved_before = true;\r\n           if(player_turn === \"white\"){\r\n               canWhiteCastle = false;\r\n           } else {\r\n               canBlackCastle = false;\r\n           }\r\n       }\r\n       //\r\n\r\n        // swapping the elements in the board (the current one we clicked with the previous one we clicked)\r\n        swap(board_copy, i, j, previous_i, previous_j);\r\n        console.log(\"moved!\");\r\n\r\n        // specific to pawns: after moving them for the first time, we have to set their moved_before attribute to true. This will enable us to use their second set of valid moves next time we want to move the same pawn\r\n        if((board_copy[i][j].piece === \"Pawn\"|| board_copy[i][j].piece === \"Rook\") && board_copy[i][j].moved_before === false){\r\n            board_copy[i][j].moved_before = true;\r\n        }\r\n\r\n        // promoting a pawn that reached the end of the board\r\n        promotePawn(board_copy, i, j, previous_i, previous_j);\r\n\r\n        // checking if I put them in check after my move\r\n        let didIPutThemInCheck:boolean = false;\r\n\r\n        let [enemyKing_x, enemyKing_y] = findEnemyKing(board_copy, player_turn) // find the enemy's king\r\n\r\n        let copy_1 = JSON.parse(JSON.stringify(board_copy));\r\n        let copy_2 = JSON.parse(JSON.stringify(board_copy));\r\n\r\n        // this function will return all the possible locations that I can capture as of the current board state (including my last move)\r\n        // notice that I'm passing the opposite color to the turn. This is because of how I wrote that function in ./check\r\n        let allMyNextPossibleMoves = getAllAttackLocations(copy_1, copy_2, player_turn === \"white\" ? \"black\" : \"white\");\r\n\r\n        // as of the current board state, is the opponent's king under check?\r\n        for(let index = 0; index < allMyNextPossibleMoves.length; index++){\r\n            for(let indexx = 0 ; indexx < allMyNextPossibleMoves[index].length ; indexx++){\r\n                let x = allMyNextPossibleMoves[index][indexx].x;\r\n                let y = allMyNextPossibleMoves[index][indexx].y;\r\n                if(x === enemyKing_x && y === enemyKing_y){\r\n                    didIPutThemInCheck = true;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // we successfully made a move. now we need to switch the turns so that the opposite color can play\r\n        player_turn === \"white\" ? player_turn = \"black\" : player_turn = \"white\";\r\n        \r\n        // update the board and reset the previous selection to be nothing + update history array for undoing\r\n        instance.setState( (prevState:State) => ({\r\n            board: JSON.parse(JSON.stringify(board_copy)),\r\n            selected_piece: { i : \"\", j : \"\", value : \"\", validCoordinates: [] }, // resetting the selection to nothing and the validcoordinates to nothing\r\n            squareColor: JSON.parse(JSON.stringify(default_squareColor)),\r\n            turn: player_turn, // update the color of the turn\r\n            history: [...prevState.history, JSON.parse(JSON.stringify(board_copy))], // storing history for undo button\r\n            in_check: [...prevState.in_check, didIPutThemInCheck], // appending the state of check for the undo button\r\n            can_white_castle: [...prevState.can_white_castle, canWhiteCastle],\r\n            can_black_castle: [...prevState.can_black_castle, canBlackCastle]\r\n        }));\r\n    }\r\n\r\n} \r\n\r\n/****************************************************************************************************/\r\nfunction checkForEnPassant(board_copy:Array<Array<Piece>>, i:number, j:number, previous_i:number, previous_j:number, validLocationsToMoveTo:Array<Move>){\r\n\r\n    // check if the piece we're trying to move is a Pawn and that we're trying to move it to an empty square\r\n    if(board_copy[previous_i][previous_j].piece === \"Pawn\" && board_copy[i][j].piece === \"\"){\r\n\r\n        if(board_copy[previous_i][previous_j].color === \"white\"){\r\n            if(j !== previous_j){ // i.e. we're trying to move a pawn diagonally to a non-empty square\r\n                board_copy[i+1][j] = {image: \"\", piece: \"\", color: \"\", move : []}; // capture the opponent's pawn below us\r\n            }\r\n\r\n        } else {\r\n            if(j !== previous_j){\r\n                board_copy[i-1][j] = {image: \"\", piece: \"\", color: \"\", move : []};\r\n            }\r\n        }\r\n        \r\n    }\r\n}\r\n/****************************************************************************************************/\r\nfunction checkCastling(board_copy:Array<Array<Piece>>, i:number, j:number, previous_i:number, previous_j:number, validLocationsToMoveTo:Array<Move>){\r\n    if(j - previous_j === 2){\r\n        swap(board_copy, i, j-1, i, 7);\r\n    } else if (previous_j - j === 2){\r\n        swap(board_copy, i, j+1, i, 0);\r\n    }\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {getColor} from './highlighting';\r\nimport {pieces} from './initialBoard';\r\nimport {startAnalysis} from './startAnalysis';\r\n\r\n// just storing a copy of the default chess color puzzle. This is so that we can reset to this set of colors when needed\r\nlet default_squareColor = new Array(8).fill(\"\").map((value, index) => new Array(8).fill(\"\").map( (value_2, indexx) => getColor(index, indexx) )  )\r\n\r\nconst Square = (props) => {\r\n    return(\r\n        <div className=\"square\">\r\n            <button style={{backgroundColor: props.color}} onClick={props.onClick}>\r\n                <div className=\"piece\">\r\n                    {props.image ?\r\n                    <img src={props.image} alt=\"\"></img>\r\n                    :\r\n                    <div />\r\n                    }\r\n                </div>\r\n            </button>\r\n        </div>\r\n    );\r\n}\r\n\r\nclass ChessBoard extends React.Component {\r\n    \r\n    renderSquare(i, j){\r\n        return <Square \r\n                    image={this.props.pieces[i][j].image}  \r\n                    onClick={() => this.props.handleClick(i, j)} \r\n                    color={this.props.squareColor[i][j]}>\r\n                </Square>\r\n    }\r\n\r\n    render(){\r\n        return( \r\n            <div className=\"board\">\r\n\r\n                <div className=\"col-label-top\">\r\n                    <div>a</div>\r\n                    <div>b</div>\r\n                    <div>c</div>\r\n                    <div>d</div>\r\n                    <div>e</div>\r\n                    <div>f</div>\r\n                    <div>g</div>\r\n                    <div>h</div>\r\n                </div>\r\n\r\n                <div className=\"row\" id=\"row-0\">\r\n                    <div className=\"row-label-left\">8</div>\r\n                    {this.renderSquare(0, 0)} \r\n                    {this.renderSquare(0, 1)}\r\n                    {this.renderSquare(0, 2)}\r\n                    {this.renderSquare(0, 3)}\r\n                    {this.renderSquare(0, 4)}\r\n                    {this.renderSquare(0, 5)}\r\n                    {this.renderSquare(0, 6)}\r\n                    {this.renderSquare(0, 7)}\r\n                    <div className=\"row-label-right\">8</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-1\">\r\n                    <div className=\"row-label-left\">7</div>\r\n                    {this.renderSquare(1, 0)}\r\n                    {this.renderSquare(1, 1)}\r\n                    {this.renderSquare(1, 2)}\r\n                    {this.renderSquare(1, 3)}\r\n                    {this.renderSquare(1, 4)}\r\n                    {this.renderSquare(1, 5)}\r\n                    {this.renderSquare(1, 6)}\r\n                    {this.renderSquare(1, 7)}\r\n                    <div className=\"row-label-right\">7</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-2\">\r\n                    <div className=\"row-label-left\">6</div>\r\n                    {this.renderSquare(2, 0)}\r\n                    {this.renderSquare(2, 1)}\r\n                    {this.renderSquare(2, 2)}\r\n                    {this.renderSquare(2, 3)}\r\n                    {this.renderSquare(2, 4)}\r\n                    {this.renderSquare(2, 5)}\r\n                    {this.renderSquare(2, 6)}\r\n                    {this.renderSquare(2, 7)}\r\n                    <div className=\"row-label-right\">6</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-3\">\r\n                    <div className=\"row-label-left\">5</div>\r\n                    {this.renderSquare(3, 0)}\r\n                    {this.renderSquare(3, 1)}\r\n                    {this.renderSquare(3, 2)}\r\n                    {this.renderSquare(3, 3)}\r\n                    {this.renderSquare(3, 4)}\r\n                    {this.renderSquare(3, 5)}\r\n                    {this.renderSquare(3, 6)}\r\n                    {this.renderSquare(3, 7)}\r\n                    <div className=\"row-label-right\">5</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-4\">\r\n                    <div className=\"row-label-left\">4</div>\r\n                    {this.renderSquare(4, 0)}\r\n                    {this.renderSquare(4, 1)}\r\n                    {this.renderSquare(4, 2)}\r\n                    {this.renderSquare(4, 3)}\r\n                    {this.renderSquare(4, 4)}\r\n                    {this.renderSquare(4, 5)}\r\n                    {this.renderSquare(4, 6)}\r\n                    {this.renderSquare(4, 7)}\r\n                    <div className=\"row-label-right\">4</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-5\">\r\n                    <div className=\"row-label-left\">3</div>\r\n                    {this.renderSquare(5, 0)}\r\n                    {this.renderSquare(5, 1)}\r\n                    {this.renderSquare(5, 2)}\r\n                    {this.renderSquare(5, 3)}\r\n                    {this.renderSquare(5, 4)}\r\n                    {this.renderSquare(5, 5)}\r\n                    {this.renderSquare(5, 6)}\r\n                    {this.renderSquare(5, 7)}\r\n                    <div className=\"row-label-right\">3</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-6\">\r\n                    <div className=\"row-label-left\">2</div>\r\n                    {this.renderSquare(6, 0)}\r\n                    {this.renderSquare(6, 1)}\r\n                    {this.renderSquare(6, 2)}\r\n                    {this.renderSquare(6, 3)}\r\n                    {this.renderSquare(6, 4)}\r\n                    {this.renderSquare(6, 5)}\r\n                    {this.renderSquare(6, 6)}\r\n                    {this.renderSquare(6, 7)}\r\n                    <div className=\"row-label-right\">2</div>\r\n                </div>\r\n                <div className=\"row\" id=\"row-7\">\r\n                    <div className=\"row-label-left\">1</div>\r\n                    {this.renderSquare(7, 0)}\r\n                    {this.renderSquare(7, 1)}\r\n                    {this.renderSquare(7, 2)}\r\n                    {this.renderSquare(7, 3)}\r\n                    {this.renderSquare(7, 4)}\r\n                    {this.renderSquare(7, 5)}\r\n                    {this.renderSquare(7, 6)}\r\n                    {this.renderSquare(7, 7)}\r\n                    <div className=\"row-label-right\">1</div>\r\n                </div>\r\n\r\n                <div className=\"col-label-bottom\">\r\n                    <div>a</div>\r\n                    <div>b</div>\r\n                    <div>c</div>\r\n                    <div>d</div>\r\n                    <div>e</div>\r\n                    <div>f</div>\r\n                    <div>g</div>\r\n                    <div>h</div>\r\n                </div>\r\n\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nlet TurnTracker = (props) => {\r\n    return(\r\n        <div style={{color: props.value}} id=\"Turn-tracker\">\r\n            {props.value}'s turn\r\n        </div>\r\n    );\r\n}\r\n\r\nlet Check = (props) => {\r\n    return(\r\n        <div>\r\n            {props.value ? \r\n                <p style={{color:\"red\"}} id=\"check\">check</p>\r\n            :\r\n                <div/>\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nlet Undo = (props) => {\r\n    return(\r\n        <div id=\"undo\">\r\n            <button onClick={props.handleUndo}>\r\n                Undo\r\n            </button>\r\n        </div>\r\n    );\r\n}\r\n\r\nlet NewGame = () => {\r\n    return(\r\n        <div id=\"New-Game\">\r\n            <button onClick={() => window.location.reload()}>\r\n                New Game\r\n            </button>\r\n        </div>\r\n    );\r\n}\r\n\r\nclass App  extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            board: JSON.parse(JSON.stringify(pieces)), //board is an array of the \"pieces\" object. See ./initialBoard for object properties. Using JSON parse and stringify to deep clone the array \"pieces\"\r\n            selected_piece: { i : \"\", j : \"\", value : \"\", validCoordinates: [] }, // valid coordinates stores all the locations of the valid moves for the piece selected\r\n            squareColor: default_squareColor, // squareColor is the 2D array of square colors for the puzzle that is passed every render cycle to the children\r\n            turn: \"white\",\r\n            history: [JSON.parse(JSON.stringify(pieces))], // array to store all the history of moves. Used for the undo button\r\n            in_check: [false], // array to store the history of in-check warnings so that undo can function accurately\r\n            can_white_castle: [true],\r\n            can_black_castle: [true]\r\n        }\r\n        this.handleClick = this.handleClick.bind(this);\r\n        this.handleUndoClick = this.handleUndoClick.bind(this);\r\n    }\r\n\r\n    handleClick(i, j){\r\n        //an object with info about the box we just clicked\r\n        let clicked_piece = this.state.board[i][j];\r\n \r\n        // analyze whether we're trying to move our piece to a blank square, trying to capture, in check, etc..\r\n        startAnalysis(this, i, j, clicked_piece, this.state, default_squareColor);\r\n    }\r\n    \r\n    handleUndoClick(){\r\n        // ugly - return state back to what it was\r\n        this.setState( (prevState) => ({\r\n            board: prevState.history.length > 1 ? prevState.history.slice(0, prevState.history.length - 1).pop() : prevState.history[0], // not the smartest way\r\n            history: prevState.history.length > 1 ? prevState.history.slice(0, prevState.history.length - 1) : prevState.history.slice(), // not the smartest way\r\n            turn: prevState.history.length === 1 ? \"white\" :  prevState.turn === \"black\" ? \"white\" : \"black\", // not the smartest way\r\n            squareColor: default_squareColor,\r\n            selected_piece: { i : \"\", j : \"\", value : \"\", validCoordinates: [] },\r\n            in_check: prevState.in_check.slice(0, prevState.in_check.length - 1),\r\n            can_white_castle: prevState.can_white_castle.slice(0, prevState.can_white_castle.length - 1),\r\n            can_black_castle: prevState.can_black_castle.slice(0, prevState.can_black_castle.length - 1)\r\n        }));\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <div id=\"github-logo-wrapper\">\r\n                    <a title=\"GitHub Repository\" href=\"https://github.com/MohamedElassar/chess\" target=\"_blank\" rel=\"noreferrer\">\r\n                    <img className=\"github-logo\" src=\"https://image.flaticon.com/icons/svg/25/25231.svg\" alt=\"Github logo\" />\r\n                    </a>\r\n                </div>\r\n                <div id=\"board-wrapper\">\r\n                    <TurnTracker value={this.state.turn} />\r\n                    <Check value={this.state.in_check[this.state.in_check.length - 1]}></Check> \r\n                    <ChessBoard pieces={this.state.board} squareColor={this.state.squareColor} handleClick={(i, j) => this.handleClick(i, j)} />\r\n                    <div id=\"bottom-buttons\">\r\n                        <Undo handleUndo={() => this.handleUndoClick()}/>\r\n                        <NewGame></NewGame>    \r\n                    </div>  \r\n                </div>\r\n            </div>\r\n        );\r\n    }   \r\n}\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n","import {Piece, Move} from './initialBoard'; // importing the interfaces from the initalBoard file which defines each piece object\r\nimport {findTheHighlightedSquares} from './highlighting'; // function to color the right squares when we select a chess piece\r\nimport {makeMove} from './move';\r\n/****************************************************************************************************/\r\nexport interface SelectedPiece {\r\n    i: number | string;\r\n    j: number | string;\r\n    value: number | string;\r\n    validCoordinates: Move[];\r\n}\r\n\r\nexport interface State {\r\n    board: Array<Array<Piece>>;\r\n    selected_piece: SelectedPiece;\r\n    squareColor: Array<Array<string>>;\r\n    instance: this;\r\n    turn: string;\r\n    history: Array<Array<Piece>>[];\r\n    in_check: boolean[];\r\n    can_white_castle: boolean[];\r\n    can_black_castle: boolean[];\r\n}\r\n\r\n/****************************************************************************************************/\r\n/*\r\nfunction handles capturing when we click on a piece who's color doesn't match the turn color\r\n\r\notherwise,\r\n\r\nfunction to handle 4 situations: \r\n1) clicking an empty box after clicking an empty box \r\n2) clicking on a piece after clicking an empty box \r\n3) clicking on an empty box after clicking on a piece (EN PASSANT IS ALSO HANDLED HERE; THE CALL TO MAKEMOVE() HAS THE CHECK)\r\n4) clicking on a piece after clicking on a piece\r\n*/\r\nexport function startAnalysis(instance:any, i:number, j:number, clicked_piece:Piece, state:State, default_squareColor:Array<Array<string>>) {\r\n\r\n    // the value (e.g. \"Pawn\", \"\", etc.) and location of the click before the one we're currently analyzing\r\n    let previous_value = state.selected_piece.value;\r\n    let previous_i = state.selected_piece.i;\r\n    let previous_j = state.selected_piece.j;\r\n\r\n    // color of the current turn\r\n    let player_turn = state.turn;\r\n\r\n    // the array [{x:5, y:4}, ..., {x:6, y:6}] holds the valid moves of the piece we previously clicked. will be used for comparison against (x,y) if we click on an empty square after clicking on a piece\r\n    let validMoves = state.selected_piece.validCoordinates;\r\n\r\n    //making a copy of the board to be updated\r\n    let board_copy = JSON.parse(JSON.stringify(state.board));\r\n\r\n    // make a copy of the default square color array (brown squares) because we're about to change it to have the valid moves highlighted\r\n    let temp_squareColor = JSON.parse(JSON.stringify(default_squareColor));\r\n\r\n    // just making a deep copy of the previous piece's valid locations\r\n    let validLocationsToMoveTo = JSON.parse(JSON.stringify(validMoves));\r\n\r\n    // handling one of the 4 situations outlined above: we're not trying to capture, with the exception of en passant\r\n    if(clicked_piece.color === instance.state.turn || clicked_piece.color === \"\"){\r\n\r\n        switch (previous_value === \"\") {\r\n\r\n            case true: // if the previously selected piece was just an empty square:\r\n                switch (clicked_piece.piece === \"\") {\r\n                    case true: // previous was blank + current selection is blank\r\n                        \r\n                        // do nothing\r\n\r\n                    break;\r\n                    case false: // previous was blank + current selection is a chess piece \r\n\r\n                        // function to change the array temp_squareColor so that it holds all the locations of the squares to be highlighted pink\r\n                        validLocationsToMoveTo = findTheHighlightedSquares(state, board_copy, clicked_piece, temp_squareColor, i, j);\r\n\r\n                        instance.setState({\r\n                            selected_piece: { i : i, j : j, value : clicked_piece.piece, validCoordinates: JSON.parse(JSON.stringify(validLocationsToMoveTo)) },\r\n                            squareColor: JSON.parse(JSON.stringify(temp_squareColor)), // update the board to have highlighted pieces indicating valid moves\r\n                            });\r\n                    break;\r\n                }\r\n            break;\r\n\r\n            case false: // if the previously selected piece was an actual chess piece:\r\n                switch (clicked_piece.piece === \"\") {\r\n                    case true: // previous was a piece + current selection is a blank square. If we clicked a blank square with our previous selection being a non-empty square i.e. we'll start to analyze if a move is ok\r\n                        \r\n                        // makeMove will analyze if the proposed move is valid and will alter the board accordingly\r\n                        // note that I override the typescript types using the \"as\" keyword. This is because initally the indeces are set to \"\" so they can be either string or number\r\n                        makeMove(board_copy, i, j, previous_i as number, previous_j as number, validLocationsToMoveTo, instance, default_squareColor, player_turn, state);\r\n\r\n                    break; \r\n                    case false: // previous was a piece + current selection is a another piece\r\n\r\n                        // function to change the array temp_squareColor so that it holds all the locations of the squares to be highlighted pink\r\n                        validLocationsToMoveTo = findTheHighlightedSquares(state, board_copy, clicked_piece, temp_squareColor, i, j);\r\n\r\n                        instance.setState({\r\n                            selected_piece: { i : i, j : j, value : clicked_piece.piece, validCoordinates: JSON.parse(JSON.stringify(validLocationsToMoveTo)) },\r\n                            squareColor: JSON.parse(JSON.stringify(temp_squareColor)), // update the board to have highlighted pieces indicating valid moves\r\n                            });\r\n                    break;\r\n                }\r\n            break;\r\n        }\r\n\r\n    } else if(clicked_piece.color !== instance.state.turn) { // e.g. we clicked on a black piece in a white turn, so we'll try to see if we can capture\r\n\r\n        makeMove(board_copy, i, j, previous_i as number, previous_j as number, validMoves, instance, default_squareColor, player_turn, state);\r\n    \r\n    }\r\n\r\n}\r\n/**************************************************************************************************************************************************************/\r\n"],"sourceRoot":""}